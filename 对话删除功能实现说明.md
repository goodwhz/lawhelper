# 对话删除功能实现说明

## 概述

本功能实现了在不修改现有行级安全规则（RLS）的情况下，让用户可以删除自己的历史对话记录。通过使用数据库函数和 `SECURITY DEFINER` 权限绕过 RLS 限制，同时确保安全性。

## 实现原理

### 1. 数据库函数 (SECURITY DEFINER)

创建了三个关键数据库函数：

#### `delete_conversation_with_messages(conversation_uuid: UUID) -> JSONB`
- **权限**: 使用 `SECURITY DEFINER` 以数据库所有者权限执行
- **安全检查**: 内部验证用户只能删除自己的对话
- **功能**: 删除指定对话及其所有相关消息
- **返回**: JSON 格式的操作结果

#### `delete_multiple_conversations(conversation_ids: UUID[]) -> JSONB`
- **功能**: 批量删除多个对话
- **安全**: 逐个验证每个对话的所有权
- **返回**: 详细的批量删除结果

#### `api_delete_conversation(conversation_id: TEXT) -> JSONB`
- **功能**: 简化的API调用函数
- **参数**: 接受文本格式的对话ID并转换为UUID
- **错误处理**: 处理格式错误和其他异常

### 2. API 端点

#### 单个删除: `DELETE /api/conversations/[conversationId]`
```typescript
// 调用示例
const response = await fetch('/api/conversations/conversation-id', {
  method: 'DELETE',
})

const result = await response.json()
// 返回: { success: true, message: '对话删除成功', deleted_messages: 5 }
```

#### 批量删除: `POST /api/conversations/batch-delete`
```typescript
// 调用示例
const response = await fetch('/api/conversations/batch-delete', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({
    conversation_ids: ['id1', 'id2', 'id3']
  })
})

const result = await response.json()
// 返回: { success: true, deleted_count: 3, failed_ids: [], message: '成功删除 3 个对话，失败 0 个' }
```

### 3. 前端 Hook 更新

更新了 `useSupabaseChat` Hook：

#### `deleteConversation(conversationId: string)`
- **功能**: 删除单个对话
- **实现**: 调用新的 REST API
- **副作用**: 如果删除当前对话，清空状态

#### `deleteMultipleConversations(conversationIds: string[])`
- **功能**: 批量删除对话
- **实现**: 调用批量删除API
- **返回**: 详细的操作结果

## 安全特性

### 1. 用户权限验证
- 所有数据库函数内部都检查 `auth.uid()`
- 确保用户只能删除自己的对话
- 非认证用户无法调用任何删除函数

### 2. 数据完整性
- 利用外键约束 `ON DELETE CASCADE`
- 删除对话时自动删除相关消息
- 防止孤立数据

### 3. 错误处理
- 详细的错误信息和状态码
- 区分不同类型的失败（权限、数据不存在、格式错误等）
- 前端友好的错误消息

## 使用方法

### 1. 单个删除
```typescript
import { useSupabaseChat } from '@/components/chat/hooks/useSupabaseChat'

const { deleteConversation } = useSupabaseChat()

try {
  const result = await deleteConversation('conversation-id')
  console.log('删除成功:', result)
} catch (error) {
  console.error('删除失败:', error.message)
}
```

### 2. 批量删除
```typescript
import { useSupabaseChat } from '@/components/chat/hooks/useSupabaseChat'

const { deleteMultipleConversations } = useSupabaseChat()

try {
  const result = await deleteMultipleConversations(['id1', 'id2', 'id3'])
  console.log('批量删除结果:', result)
} catch (error) {
  console.error('批量删除失败:', error.message)
}
```

### 3. 直接API调用
```typescript
// 单个删除
const response = await fetch(`/api/conversations/${conversationId}`, {
  method: 'DELETE'
})

// 批量删除
const response = await fetch('/api/conversations/batch-delete', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ conversation_ids: ids })
})
```

## 测试

### 1. 测试页面
访问 `test-delete-conversation.html` 可以测试所有功能：
- 获取对话列表
- 单个对话删除
- 批量删除
- API直接调用测试

### 2. 测试步骤
1. 打开测试页面
2. 点击"获取对话列表"查看现有对话
3. 测试单个删除功能
4. 测试批量删除功能
5. 验证删除后列表更新

## 数据库迁移

执行以下SQL创建删除函数：

```sql
-- 迁移文件: migrations/add_delete_conversation_function.sql
-- 该迁移已自动执行，包含所有必要的数据库函数
```

## 注意事项

### 1. 不可撤销操作
- 删除操作是永久性的
- 建议在前端添加确认提示
- 考虑添加"回收站"功能（可选）

### 2. 性能考虑
- 批量删除时建议限制一次删除的数量
- 大量对话删除可能需要较长时间
- 可以考虑添加进度显示

### 3. 权限管理
- 函数内部验证确保安全性
- 无需修改现有RLS策略
- 保持了原有安全模型

## 与现有代码的兼容性

### 1. 无破坏性更改
- 保持原有软删除功能
- 新增真正的物理删除功能
- Hook接口向后兼容

### 2. 渐进式采用
- 可以逐步替换软删除逻辑
- 现有代码无需立即修改
- 支持混合使用模式

## 总结

本实现通过数据库函数和适当的安全控制，成功绕过了RLS限制，实现了用户删除自己对话的功能。该方案：

- ✅ 不修改现有RLS策略
- ✅ 保证安全性（用户只能删除自己的对话）
- ✅ 提供单个和批量删除功能
- ✅ 完整的错误处理和状态反馈
- ✅ 与现有代码兼容
- ✅ 易于测试和维护

该实现已部署并可立即使用。